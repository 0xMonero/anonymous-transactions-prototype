{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}


let depositVK=base58''
let withdrawalVK=base58''
let transferVK=base58''

func groth16Verify(vk:ByteVector, proof:ByteVector, inputs:ByteVector) = {
    true
}


func takeLR(v:ByteVector, from:Int, to:Int) = {
    takeRight(take(v, to), to-from)
}

func getUtxoKey(utxo:ByteVector) = "U:"+toBase58String(utxo)


func getSecretKey(owner:ByteVector, secret:ByteVector) = "S:"+toBase58String(keccak256(owner+secret))

func flagExists(key:String) = {
    match getBoolean(this, key) {
        case a:Boolean => a
        case _ => false
    }
}

func flagNotExists(key:String) = !flagExists(key)


# Withdrawal input structure
# public:
#   hash     256
#   balance   64
#   secret   160
#   owner    208
# private:
#   salt      80 

@Callable(i)
func withdrawal(msg:ByteVector, sig:ByteVector, pub:ByteVector) = {
    let proof = take(msg, 256);
    let v = takeRight(msg, 96);
    let hash = take(v, 32)
    let balance = toInt(v, 32 + 3*8)
    let secret = takeLR(v, 64, 96)
    let owner = addressFromPublicKey(pub).bytes
    let v2 = v + base58'111111' + owner
    let secretKey = getSecretKey(owner, secret)
    
    if (i.caller!=this) then
        throw("wrong caller")
    else if (!sigVerify(msg, sig, pub)) then 
        throw("wrong signature")
    else if (flagExists(secretKey)) then 
        throw("doublespend detected")
    else if (flagNotExists(getUtxoKey(hash))) then
        throw("utxo not exists")
    else if (!groth16Verify(withdrawalVK, proof, v2)) then 
        throw("wrong proof")
    else
        ScriptResult(
            WriteSet([DataEntry(secretKey, true)]),
            TransferSet([ScriptTransfer(Address(owner), balance, unit)])
        )
}


# Transfer input structure
# public:
#   in_hashes[8]       256
#   out_hashes[2]      256
#   in_secrets[2]      160
#   owner              208
# private:
#   in_selectors[2][8]
#   in_balances[2]      64
#   in_salts[2]         80
#   out_balance[2]      64
#   out_secrets[2]     160
#   out_salt[2]         80
#   out_owner[2]       208


@Callable(i)
func transfer(msg:ByteVector, sig:ByteVector, pub:ByteVector) = {
    let proof = take(msg, 256);
    let v = takeRight(msg, 320);
    let uk0 = getUtxoKey(takeLR(v, 0, 32))
    let uk1 = getUtxoKey(takeLR(v, 32, 64))
    let uk2 = getUtxoKey(takeLR(v, 64, 96))
    let uk3 = getUtxoKey(takeLR(v, 96, 128))
    let uk4 = getUtxoKey(takeLR(v, 128, 160))
    let uk5 = getUtxoKey(takeLR(v, 160, 192))
    let uk6 = getUtxoKey(takeLR(v, 192, 224))
    let uk7 = getUtxoKey(takeLR(v, 224, 256))
    let ouk0 = getUtxoKey(takeLR(v, 256, 288))
    let ouk1 = getUtxoKey(takeLR(v, 288, 320))
    let owner = addressFromPublicKey(pub).bytes
    let v2 = v + base58'111111' + owner

    let osk0 = getSecretKey(owner, takeLR(v, 320, 352))
    let osk1 = getSecretKey(owner, takeLR(v, 352, 384))
    
    if (i.caller!=this) then
        throw("wrong caller")
    else if (!sigVerify(msg, sig, pub)) then 
        throw("wrong signature")
    else if (flagExists(osk0) || flagExists(osk1)) then 
        throw("doublespend detected")
    else if (flagNotExists(uk0) || flagNotExists(uk1) || flagNotExists(uk2) || flagNotExists(uk3) || flagNotExists(uk4) || flagNotExists(uk5) || flagNotExists(uk6) || flagNotExists(uk7)) then
        throw("input utxo not exists")
    else if (flagExists(ouk0) || flagExists(ouk1)) then
        throw("output utxo alreadyexists")
    else if (!groth16Verify(transferVK, proof, v2)) then 
        throw("wrong proof")
    else
        WriteSet([DataEntry(ouk0, true), DataEntry(ouk1, true)])
}



# Deposit input structure
# public:
#   hash     256
#   balance   64
# private:
#   owner    208
#   secret   160
#   salt      80

@Callable(i)
func deposit(proof:ByteVector, v:ByteVector) = {
   let pmt = extract(i.payment)
   if (isDefined(pmt.assetId)) then throw("can hodl waves only at the moment")
   else {
        let hash= take(v, 32)
        let balance = pmt.amount
        let v2 = v + base58'111111111111111111111111'+toBytes(pmt.amount)
        let utxoKey = getUtxoKey(hash)
        if (flagExists(utxoKey)) then 
            throw("utxo already exists") 
        else if (!groth16Verify(depositVK, proof, v2)) then 
            throw("wrong proof")
        else
            WriteSet([DataEntry(utxoKey, true)])  
   }
}


@Verifier(tx)
func verify() = {
    match tx {
#        case tx:InvokeScriptTransaction =>  (tx.function == "transfer") || sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
        case _ => true #todo: replace to false
    }
}